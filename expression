; The python list expression AST for reference
; vim: ft=scheme

;atom = Any('x', *map(str, range(0, _N))),
;expression = Any(Get('atom'),
;                 Seq(Get('atom'), ' + ', Get('atom')),
;                 Seq(Get('atom'), ' * ', Get('atom')),
;                 Seq(Get('atom'), ' - ', Get('atom'))),

;repeat       = Seq('(', '[', Get('expression'),'] * (', Get('expression'), '))'),
;range_def    = Any(Seq('list(range(', Get('expression'), '))'),
;                   Seq('list(range(', Get('expression'), ', ', Get('expression'), '))')),
;list_literal = Seq('[', Get('expression'), Many(Seq(', ', Get('expression'))), ']'),;;

;list_def     = Any(Get('list_literal'), Get('range_def'), Get('repeat')),
;concat_def   = Any(Seq('(', Get('list_def'), ')', Many(Seq(' + (', Get('list_def'), ')'))))
;))

(define N 10)
(define (nat-operator) (uniform-draw '(+ - *))) ; No division: Produces fractional types from integers
(define (integer)  (random-integer N))
(define (atom) (if (flip) (integer) 'x))
(define (expression) (uniform-draw
                      (list
                       (atom)
                       (list (nat-operator) 'x (atom))
                       (list (nat-operator) (atom) 'x))))

(define (create-repeat) (list 'repeat (expression) (list 'lambda '() (expression))))
(define (create-range)  (list 'range (expression) (expression)))
(define (f) (list 'lambda '(x) (expression)))

(define list-expression (mh-query 100 10
  (define test-f (f))
  (define n (integer))
  (list test-f "over range 1 -" n)
  (condition (equal? (map (eval test-f) (range 1 n)) '(2 4 6 8 10)))
                              ))
;(define (rep)
;  (define n (expression))
;  (define inner-f '(mem (lambda () (expression))))
;  (list 'repeat (expression) inner-f))
  ;(list 'repeat (expression) '(mem (lambda () (expression)))))


;(apply (eval (operator)) '(1 2))

;; (define test
;;   (mh-query 1000 10
;;             (define list-f (f))
;;             list-f
;;             (condition (= (map (eval list-f) (range 1 2)) (list 1 1)))
;;             ))


;(display (expression))a
;(hist test "Test")
;(eval (f))
;(apply (eval (f)) '(1))
;(f)
;((eval (f)) 1)
;(repeat 10 (lambda () 2))
;(map (eval (f)) (range 1 10))
;(eval (rep))
;(rep)
;(hist list-expression "Function expressions that produce (2 2)")
;(eval (rep))
;(create-range)

(define (count-occurance b a)
  ;(console-log "Counting occurance of:")
  ;(console-log b)
  ;(console-log "Progress:")
  ;(console-log a)
  (if (= (length a) 0)
      (list (list b 1))
      (if (equal? (first (first a)) b)
        (append (list (list b (+ 1 (second (first a)))))
                (rest a))
        (append (list (first a)) (count-occurance b (rest a))))))

(define (count-occurances local)
  (fold count-occurance '() local))

(define (to-percents counts)
  (map (lambda (x) (list (first x)
                         (/ (second x) 
                            (fold (lambda (a b) (+ b (second a))) 0 counts))))
       counts))

(define (log-bin bin)
  (console-log (first bin))
  (console-log (apply string-append
                 (repeat (floor (* 80 (second bin)))
                   (lambda () "#")))))

(define (histogram query-list)
  (for-each log-bin 
            (to-percents (count-occurances query-list)))
  "Histogram printed successfully")

(histogram list-expression)
